# E314.DataTypes

## Описание

Модуль E314.DataTypes предоставляет структуры и типы данных.

## Содержание

- [E314.DataTypes](#e314datatypes)
  - [Описание](#описание)
  - [Содержание](#содержание)
  - [CapacityStrategy](#capacitystrategy)
    - [Рекомендации](#рекомендации)
    - [Пример использования](#пример-использования)
  - [FastList](#fastlist)
    - [Рекомендации](#рекомендации-1)
    - [Пример использования](#пример-использования-1)
  - [Binder](#binder)
    - [Основные возможности](#основные-возможности)
    - [Рекомендации](#рекомендации-2)
    - [Пример использования](#пример-использования-2)

## CapacityStrategy

Стратегия управления емкостью коллекций.
Этот класс предоставляет метод для вычисления емкости на основе ее текущего значения и требуемого размера.
Новая емкость выбирается из предопределенного массива, содержащего числа, близкие к степени два минус один `(2^n - 1)`.
Эти значения обеспечивают эффективное распределение памяти и минимизируют коллизии хэшей.

### Рекомендации

- Используйте для динамических коллекций, когда нужно эффективное распределение памяти или минимизация коллизии хэшей.
- Оцените требуемый размер заранее, чтобы избежать частых перераспределений памяти.
- Максимальная емкость ограничена значением 1,048,575. Для больших данных используйте другую стратегию.
- Если существует риск превышения максимального значения емкости, обработайте исключение `InvOpException`.
- Реализуйте интерфейс `ICapacityStrategy`, если нужна другая реализация стратегии.

### Пример использования

``` csharp
var strategy = new CapacityStrategy();
int requiredSize = 100;
int newCapacity = strategy.CalculateCapacity(0, requiredSize);
Console.WriteLine($"New capacity: {newCapacity}");
// New capacity: 127
```

## FastList

Реализация быстрого списка.
Класс предоставляет методы для быстрого добавления, удаления и доступа к элементам с минимальными накладными расходами.
Использует `ArrayPool<T>`, что минимизирует выделение памяти и уменьшает нагрузку на сборщик мусора.
Поддерживает стратегию управления емкостью через интерфейс `ICapacityStrategy`. По умолчанию используется `CapacityStrategy`.
Поддерживает перебор значений при помощи `foreach`.

### Рекомендации

- Подходит для сценариев, где требуется частое изменение размера списка.
- Если известно примерное количество элементов, инициализируйте список с соответствующей начальной емкостью, чтобы избежать частых перераспределений памяти.
- Убедитесь, что индексы находятся в допустимых пределах при использовании методов, таких как RemoveAt или доступ по индексу.
- Всегда вызывайте метод Dispose, чтобы вернуть массивы в пул и освободить ресурсы.
- Если стандартная стратегия не подходит, создайте собственную реализацию интерфейса ICapacityStrategy.

### Пример использования

``` csharp
var list = new FastList<int>();

list.Add(10);
list.Add(20);
list.Add(30);

Console.WriteLine($"Count: {list.Count}");
// Count: 3

Console.WriteLine($"Element at index 1: {list[1]}"); 
// Element at index 1: 20

bool isRemoved = list.RemoveAt(1);
// true
Console.WriteLine($"Count after removal: {list.Count}");
// Count after removal: 2

list.Clear();
Console.WriteLine($"Count after clear: {list.Count}");
// Count after clear: 0

list.Dispose();
```

## Binder

Класс `Binder<TKey, TValue>` управляет связями между ключами и значениями, реализуя интерфейс `IBinder<TKey, TValue>`.
Предоставляет методы для создания, получения и удаления привязок (bindings).
Поддерживает стратегию управления емкостью через интерфейс `ICapacityStrategy`.

### Основные возможности

- Создание привязок: Создает новую привязку для ключа или возвращает существующую.
- Удаление привязок: Удаляет привязку для указанного ключа и освобождает связанные ресурсы.
- Получение привязок: Возвращает привязку для ключа, если она существует, или `null`, если ключ отсутствует.
- Освобождение ресурсов: Реализует интерфейс `IDisposable` для освобождения всех ресурсов, связанных с привязками.

### Рекомендации

- Подходит для сценариев, где требуется создавать и удалять связи между объектами (например, в системах событий, зависимостей или инъекции данных).
- Если известно примерное количество привязок, укажите начальную емкость при инициализации, чтобы минимизировать перераспределения памяти.
- Убедитесь, что ключи не являются `null`, так как это вызовет исключение `ArgNullException`.
- Убедитесь, что объект не был освобожден (`Dispose`), перед выполнением операций.
- Всегда вызывайте метод `Dispose`, чтобы освободить все привязки и связанные ресурсы.
- Методы поддерживают цепочку вызовов (Fluent-интерфейс), что делает код более читаемым и компактным.

### Пример использования

``` csharp
var capacityStrategy = new CapacityStrategy();
var binder = new Binder<string, object>(10, capacityStrategy);

binder.Bind("Key1").To(new object());
var binding = binder.GetBinding("Key1");
bool isUnbound = binder.Unbind("Key1");

binder.Dispose();
```
